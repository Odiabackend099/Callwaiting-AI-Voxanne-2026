import axios, { AxiosInstance, AxiosError } from 'axios';
import { createLogger } from './logger';

const logger = createLogger('VapiClient');

// ========== CIRCUIT BREAKER ==========

interface CircuitBreakerState {
  failures: number;
  lastFailure: number;
  isOpen: boolean;
}

const CIRCUIT_BREAKER_THRESHOLD = 5; // Open circuit after 5 failures
const CIRCUIT_BREAKER_RESET_MS = 60000; // Reset after 1 minute

// ========== INTERFACES ==========

/**
 * Configuration for creating a Vapi assistant
 */
export interface AssistantConfig {
  name: string;
  systemPrompt: string;
  voiceProvider?: string;
  voiceId?: string;
  language?: string;
  firstMessage?: string;
  maxDurationSeconds?: number;
  modelProvider?: string;
  modelName?: string;
  serverUrl?: string;
  serverMessages?: string[];
  transcriber?: {
    provider: string;
    model?: string;
    language?: string;
  };
  functions?: any[];
  tools?: VapiTool[]; // Modern tools array
}

/**
 * Modern Vapi Tool Interface (replaces legacy functions)
 */
export interface VapiTool {
  id?: string; // Auto-generated by Vapi dashboard
  type: 'query' | 'server';
  name: string;
  description: string;
  query?: {
    knowledgeBases: Array<{
      name: string;
      description: string;
      fileIds: string[]; // KB file IDs from uploads
    }>;
  };
  server?: {
    url: string;
    method: 'POST';
  };
  messages?: {
    requestStart?: string[];
    requestComplete?: string[];
    requestFailed?: string[];
    requestDelayed?: string[];
  };
}


export interface CreateCallParams {
  assistantId: string;
  phoneNumberId: string;
  customer: {
    number: string;
    name?: string;
  };
  assistantOverrides?: {
    variableValues?: Record<string, string>;  // For {{variable}} substitution in prompts
    metadata?: Record<string, any>;           // For tracking in webhooks/tools
    firstMessage?: string;                    // Override first message with personalized greeting
  };
  idempotencyKey?: string;                    // For deduplication on retries
}

export interface ImportTwilioParams {
  phoneNumber: string;
  twilioAccountSid: string;
  twilioAuthToken: string;
  name?: string;
}

export class VapiClient {
  private client: AxiosInstance;
  private apiKey: string;
  private circuitBreaker: CircuitBreakerState;

  constructor(apiKey: string) {
    // CRITICAL: Sanitize API key to prevent "Invalid character in header content" errors
    // Remove all control characters, newlines, carriage returns, and whitespace
    const sanitizedKey = (apiKey || '')
      .trim()
      .replace(/[\r\n\t\x00-\x1F\x7F]/g, ''); // Remove all control characters

    if (!sanitizedKey) {
      throw new Error('VapiClient: API key is required and cannot be empty');
    }

    this.apiKey = sanitizedKey;

    this.circuitBreaker = {
      failures: 0,
      lastFailure: 0,
      isOpen: false
    };

    this.client = axios.create({
      baseURL: 'https://api.vapi.ai',
      headers: {
        'Authorization': `Bearer ${sanitizedKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });

    // Retry logic with exponential backoff for 5xx errors
    this.client.interceptors.response.use(
      response => response,
      async error => {
        // If config is missing, we can't retry, so just reject
        if (!error.config) {
          return Promise.reject(error);
        }

        const config = error.config as any;

        if (config.retry === undefined) {
          config.retry = 0;
        }

        const method = (config.method || 'get').toString().toUpperCase();
        const isSafeMethod = method === 'GET' || method === 'HEAD' || method === 'OPTIONS';
        const status = error.response?.status;
        const retryAfterHeader = error.response?.headers?.['retry-after'];
        const retryAfterSeconds = retryAfterHeader ? Number(retryAfterHeader) : NaN;

        // Retry on 5xx server errors AND network errors, max 3 attempts
        const isRetryableError =
          (status && (status >= 500 || status === 429)) ||
          error.code === 'ECONNREFUSED' ||
          error.code === 'ETIMEDOUT' ||
          error.code === 'ECONNABORTED';

        if (config.retry < 3 && isRetryableError && isSafeMethod) {
          config.retry += 1;
          const baseDelay = Math.pow(2, config.retry) * 1000;
          const retryAfterMs = Number.isFinite(retryAfterSeconds) ? Math.max(0, retryAfterSeconds * 1000) : 0;
          const jitter = Math.floor(Math.random() * 250);
          const delay = Math.max(baseDelay, retryAfterMs) + jitter;
          logger.warn('Retrying request after retryable error', { attempt: config.retry, maxAttempts: 3, delayMs: delay });
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.client(config);
        }

        return Promise.reject(error);
      }
    );
  }

  private checkCircuitBreaker(): void {
    if (this.circuitBreaker.isOpen && Date.now() - this.circuitBreaker.lastFailure > CIRCUIT_BREAKER_RESET_MS) {
      logger.info('Circuit breaker reset - attempting to reconnect');
      this.circuitBreaker.isOpen = false;
      this.circuitBreaker.failures = 0;
    }

    if (this.circuitBreaker.isOpen) {
      throw new Error('Vapi API circuit breaker is open. Service temporarily unavailable. Please try again later.');
    }
  }

  private recordFailure(): void {
    this.circuitBreaker.failures++;
    this.circuitBreaker.lastFailure = Date.now();

    if (this.circuitBreaker.failures >= CIRCUIT_BREAKER_THRESHOLD) {
      logger.error('Circuit breaker opened', { failures: this.circuitBreaker.failures });
      this.circuitBreaker.isOpen = true;
    }
  }

  private recordSuccess(): void {
    if (this.circuitBreaker.failures > 0) {
      this.circuitBreaker.failures = 0;
    }
  }

  public getCircuitBreakerStatus(): { isOpen: boolean; failures: number; lastFailure: number } {
    return { ...this.circuitBreaker };
  }

  private async request<T>(fn: () => Promise<{ data: T }>, logContext?: Record<string, any>): Promise<T> {
    this.checkCircuitBreaker();
    try {
      const response = await fn();
      this.recordSuccess();
      return response.data;
    } catch (error) {
      this.recordFailure();
      logger.exception('Vapi request failed', error as Error, logContext);
      throw error;
    }
  }

  // ========== ASSISTANTS ==========

  /**
   * Create a new Vapi assistant
   * @param config Assistant configuration
   * @returns Created assistant object
   * @throws Error if API request fails
   */
  async createAssistant(config: AssistantConfig): Promise<any> {
    const payload: any = {
      name: config.name,
      serverUrl: config.serverUrl,
      serverMessages: config.serverMessages, // Pass serverMessages
      model: {
        provider: config.modelProvider || 'openai',
        model: config.modelName || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: config.systemPrompt
          }
        ]
      },
      voice: {
        provider: config.voiceProvider || 'vapi',
        voiceId: config.voiceId || 'Paige'
      },
      transcriber: config.transcriber || {
        provider: 'deepgram',
        model: 'nova-2',
        language: config.language || 'en'  // Use stored language
      },
      firstMessage: config.firstMessage || 'Hello! How can I help you today?',
      recordingEnabled: true  // CRITICAL: Enable recording for all calls
    };

    // Only include tools if explicitly provided; some Vapi routes reject tools on creation
    if (config.tools && config.tools.length > 0) {
      payload.tools = config.tools;
    }

    // Add maxDurationSeconds if provided
    if (config.maxDurationSeconds) {
      payload.maxDurationSeconds = config.maxDurationSeconds;
    }

    return await this.request<any>(() => this.client.post('/assistant', payload), { route: 'POST /assistant' });
  }

  async updateAssistant(assistantId: string, updates: any) {
    return await this.request<any>(() => this.client.patch(`/assistant/${assistantId}`, updates), { route: 'PATCH /assistant/:id', assistantId });
  }

  async getAssistant(assistantId: string) {
    return await this.request<any>(() => this.client.get(`/assistant/${assistantId}`), { route: 'GET /assistant/:id', assistantId });
  }

  async listAssistants() {
    return await this.request<any>(() => this.client.get('/assistant'), { route: 'GET /assistant' });
  }

  async getTool(toolId: string) {
    return await this.request<any>(() => this.client.get(`/tool/${toolId}`), { route: 'GET /tool/:id', toolId });
  }

  async validateConnection(): Promise<boolean> {
    try {
      // Use this.request() to respect circuit breaker
      await this.request<any>(() => this.client.get('/assistant', { params: { limit: 1 } }), { route: 'GET /assistant (validation)' });
      return true;
    } catch (error) {
      logger.warn('Connection validation failed', { error: (error as any)?.message });
      return false;
    }
  }

  async listVoices() {
    try {
      const response = await this.client.get('/voice');
      return response.data;
    } catch (error) {
      logger.warn('Failed to list voices from API, might not be supported', { error: (error as any)?.message });
      return [];
    }
  }

  // ========== CALLS ==========

  async createOutboundCall(params: CreateCallParams) {
    const payload: any = {
      assistantId: params.assistantId,
      phoneNumberId: params.phoneNumberId,
      customer: {
        number: params.customer.number,
        name: params.customer.name
      }
    };

    // NOTE: idempotencyKey was removed - Vapi API rejects this field with:
    // "property idempotencyKey should not exist"

    // Add assistantOverrides for lead personalization (variableValues + metadata + firstMessage)
    if (params.assistantOverrides) {
      payload.assistantOverrides = {};
      if (params.assistantOverrides.variableValues) {
        payload.assistantOverrides.variableValues = params.assistantOverrides.variableValues;
      }
      if (params.assistantOverrides.metadata) {
        payload.assistantOverrides.metadata = params.assistantOverrides.metadata;
      }
      if (params.assistantOverrides.firstMessage) {
        payload.assistantOverrides.firstMessage = params.assistantOverrides.firstMessage;
      }
    }

    return await this.request<any>(() => this.client.post('/call/phone', payload), { route: 'POST /call/phone' });
  }

  async getCall(callId: string) {
    return await this.request<any>(() => this.client.get(`/call/${callId}`), { route: 'GET /call/:id', callId });
  }

  async createWebSocketCall(params: {
    assistantId: string;
    audioFormat: {
      format: 'pcm_s16le' | 'mulaw';
      container: 'raw';
      sampleRate: number;
    };
  }) {
    const payload = {
      assistantId: params.assistantId,
      transport: {
        provider: 'vapi.websocket',
        audioFormat: params.audioFormat
      }
    };

    return await this.request<any>(() => this.client.post('/call', payload), { route: 'POST /call' });
  }

  async endCall(callId: string) {
    return await this.request<any>(() => this.client.delete(`/call/${callId}`), { route: 'DELETE /call/:id', callId });
  }

  async listCalls(limit: number = 50) {
    return await this.request<any>(() => this.client.get('/call', { params: { limit } }), { route: 'GET /call' });
  }

  // ========== PHONE NUMBERS ==========

  async createVapiPhoneNumber(name: string = 'Default Outbound Number') {
    const payload = {
      provider: 'vapi',
      name: name
    };

    const result = await this.request<any>(() => this.client.post('/phone-number', payload), { route: 'POST /phone-number' });
    logger.info('Created Vapi phone number', { phoneNumberId: result?.id });
    return result;
  }

  async importTwilioNumber(params: ImportTwilioParams) {
    const payload = {
      provider: 'twilio',
      number: params.phoneNumber,
      twilioAccountSid: params.twilioAccountSid,
      twilioAuthToken: params.twilioAuthToken
    };

    return await this.request<any>(() => this.client.post('/phone-number', payload), { route: 'POST /phone-number (twilio)' });
  }

  async getPhoneNumber(phoneNumberId: string) {
    return await this.request<any>(() => this.client.get(`/phone-number/${phoneNumberId}`), { route: 'GET /phone-number/:id', phoneNumberId });
  }

  async listPhoneNumbers() {
    const payload: any = await this.request<any>(() => this.client.get('/phone-number'), { route: 'GET /phone-number' });
    if (Array.isArray(payload)) return payload;
    if (Array.isArray(payload?.data)) return payload.data;
    if (Array.isArray(payload?.items)) return payload.items;
    logger.warn('Unexpected phone numbers response format, returning empty array', { payloadType: typeof payload });
    return [];
  }

  async updatePhoneNumber(phoneNumberId: string, updates: any) {
    return await this.request<any>(() => this.client.patch(`/phone-number/${phoneNumberId}`, updates), { route: 'PATCH /phone-number/:id', phoneNumberId });
  }

  async deletePhoneNumber(phoneNumberId: string) {
    return await this.request<any>(() => this.client.delete(`/phone-number/${phoneNumberId}`), { route: 'DELETE /phone-number/:id', phoneNumberId });
  }

  /**
   * Get default demo delivery tools in modern Vapi tools format
   * These are server-type tools that send demo videos via email, SMS, or WhatsApp
   */
  /**
   * Get default demo tools for new assistants
   * Returns modern 'server' type tools instead of legacy functions
   */
  public getDefaultDemoTools(): VapiTool[] {
    const baseUrl = process.env.RENDER_EXTERNAL_URL || process.env.BASE_URL;
    if (!baseUrl || baseUrl.includes('localhost')) {
      logger.warn('BASE_URL not configured or is localhost - demo tools may not work in production', { baseUrl });
    }

    return [
      {
        type: 'server',
        name: 'send_demo_email',
        description: 'Sends a demo video to the prospect via email. ASK FOR EMAIL FIRST.',
        server: {
          url: `${baseUrl}/api/vapi/tools/email`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending that email now...', 'I am sending the demo to your email...'],
          requestComplete: ['Email sent successfully!'],
          requestFailed: ['I had trouble sending the email. Let me try again.']
        }
      },
      {
        type: 'server',
        name: 'send_demo_whatsapp',
        description: 'Sends a demo video or message via WhatsApp.',
        server: {
          url: `${baseUrl}/api/vapi/tools/whatsapp`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending WhatsApp message...', 'One moment while I send that...'],
          requestComplete: ['WhatsApp message sent!'],
          requestFailed: ['Unable to send via WhatsApp right now.']
        }
      },
      {
        type: 'server',
        name: 'send_demo_sms',
        description: 'Sends a demo video or text via SMS.',
        server: {
          url: `${baseUrl}/api/vapi/tools/sms`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending text message...', 'Texting you the demo now...'],
          requestComplete: ['Text sent! Check your messages.'],
          requestFailed: ['Could not send the SMS.']
        }
      }
    ];
  }

  /**
   * Get default demo delivery function definitions for Vapi assistant
   * These functions allow the AI to send demo videos via email, SMS, or WhatsApp
   * @deprecated Use getDefaultDemoTools() for modern tools format
   */
  public getDefaultDemoFunctions() {

    const baseUrl = process.env.RENDER_EXTERNAL_URL || process.env.BASE_URL;
    if (!baseUrl || baseUrl.includes('localhost')) {
      logger.warn('BASE_URL not configured or is localhost - demo functions may not work in production', { baseUrl });
    }

    return [
      {
        name: 'send_demo_email',
        description: 'Send a demo video via email to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_email: {
              type: 'string',
              description: 'The prospect\'s email address'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_email', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-email`,
        //   method: 'POST'
        // }
      },
      {
        name: 'send_demo_whatsapp',
        description: 'Send a demo video via WhatsApp to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_phone: {
              type: 'string',
              description: 'The prospect\'s phone number with country code'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_phone', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-whatsapp`,
        //   method: 'POST'
        // }
      },
      {
        name: 'send_demo_sms',
        description: 'Send a demo video via SMS to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_phone: {
              type: 'string',
              description: 'The prospect\'s phone number with country code'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_phone', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-sms`,
        //   method: 'POST'
        // }
      }
    ];
  }
}

export default VapiClient;
