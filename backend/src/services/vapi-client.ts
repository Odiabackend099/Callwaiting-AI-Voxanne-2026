import axios, { AxiosInstance, AxiosError } from 'axios';
import { createLogger } from './logger';
import { config } from '../config/index';
import { assertOutboundCallReady } from '../utils/outbound-call-preflight';
// DISABLED: Vapi API doesn't support fallbacks property
// import { mergeFallbacksIntoPayload } from '../config/vapi-fallbacks';

const logger = createLogger('VapiClient');

// ========== CIRCUIT BREAKER ==========

interface CircuitBreakerState {
  failures: number;
  lastFailure: number;
  isOpen: boolean;
}

const CIRCUIT_BREAKER_THRESHOLD = 5; // Open circuit after 5 failures
const CIRCUIT_BREAKER_RESET_MS = 60000; // Reset after 1 minute

// ========== INTERFACES ==========

/**
 * Configuration for creating a Vapi assistant
 */
export interface AssistantConfig {
  name: string;
  systemPrompt: string;
  voiceProvider?: string;
  voiceId?: string;
  language?: string;
  firstMessage?: string;
  maxDurationSeconds?: number;
  modelProvider?: string;
  modelName?: string;
  serverUrl?: string;
  serverMessages?: string[];
  transcriber?: {
    provider: string;
    model?: string;
    language?: string;
  };
  functions?: any[];
  tools?: VapiTool[]; // Modern tools array
}

/**
 * Modern Vapi Tool Interface (replaces legacy functions)
 */
export interface VapiTool {
  id?: string; // Auto-generated by Vapi dashboard
  type: 'query' | 'server';
  name: string;
  description: string;
  query?: {
    knowledgeBases: Array<{
      name: string;
      description: string;
      fileIds: string[]; // KB file IDs from uploads
    }>;
  };
  server?: {
    url: string;
    method: 'POST';
  };
  messages?: {
    requestStart?: string[];
    requestComplete?: string[];
    requestFailed?: string[];
    requestDelayed?: string[];
  };
}


export interface CreateCallParams {
  assistantId: string;
  phoneNumberId: string;
  customer: {
    number: string;
    name?: string;
  };
  assistantOverrides?: {
    variableValues?: Record<string, string>;  // For {{variable}} substitution in prompts
    metadata?: Record<string, any>;           // For tracking in webhooks/tools
    firstMessage?: string;                    // Override first message with personalized greeting
  };
  idempotencyKey?: string;                    // For deduplication on retries
}

export interface ImportTwilioParams {
  phoneNumber: string;
  twilioAccountSid: string;
  twilioAuthToken: string;
  name?: string;
}

export class VapiClient {
  private client: AxiosInstance;
  private apiKey: string;
  private circuitBreaker: CircuitBreakerState;

  constructor(apiKey?: string) {
    // CRITICAL: Sanitize API key to prevent "Invalid character in header content" errors
    // Use passed key or fallback to VAPI_PRIVATE_KEY from centralized config
    const keySource = apiKey || config.VAPI_PRIVATE_KEY || '';

    const sanitizedKey = keySource
      .trim()
      .replace(/[\r\n\t\x00-\x1F\x7F]/g, '') // Remove all control characters
      .replace(/^['"]|['"]$/g, ''); // Remove wrapping quotes

    if (!sanitizedKey) {
      throw new Error('VapiClient: API key is required and cannot be empty (checked constructor arg and VAPI_PRIVATE_KEY from config)');
    }

    this.apiKey = sanitizedKey;

    this.circuitBreaker = {
      failures: 0,
      lastFailure: 0,
      isOpen: false
    };

    this.client = axios.create({
      baseURL: 'https://api.vapi.ai',
      headers: {
        'Authorization': `Bearer ${sanitizedKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });

    // Retry logic with exponential backoff for 5xx errors
    this.client.interceptors.response.use(
      response => response,
      async error => {
        // If config is missing, we can't retry, so just reject
        if (!error.config) {
          return Promise.reject(error);
        }

        const config = error.config as any;

        if (config.retry === undefined) {
          config.retry = 0;
        }

        const method = (config.method || 'get').toString().toUpperCase();
        const isSafeMethod = method === 'GET' || method === 'HEAD' || method === 'OPTIONS';
        const status = error.response?.status;
        const retryAfterHeader = error.response?.headers?.['retry-after'];
        const retryAfterSeconds = retryAfterHeader ? Number(retryAfterHeader) : NaN;

        // Retry on 5xx server errors AND network errors, max 3 attempts
        const isRetryableError =
          (status && (status >= 500 || status === 429)) ||
          error.code === 'ECONNREFUSED' ||
          error.code === 'ETIMEDOUT' ||
          error.code === 'ECONNABORTED';

        if (config.retry < 3 && isRetryableError && isSafeMethod) {
          config.retry += 1;
          const baseDelay = Math.pow(2, config.retry) * 1000;
          const retryAfterMs = Number.isFinite(retryAfterSeconds) ? Math.max(0, retryAfterSeconds * 1000) : 0;
          const jitter = Math.floor(Math.random() * 250);
          const delay = Math.max(baseDelay, retryAfterMs) + jitter;
          logger.warn('Retrying request after retryable error', { attempt: config.retry, maxAttempts: 3, delayMs: delay });
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.client(config);
        }

        return Promise.reject(error);
      }
    );
  }

  private checkCircuitBreaker(): void {
    if (this.circuitBreaker.isOpen && Date.now() - this.circuitBreaker.lastFailure > CIRCUIT_BREAKER_RESET_MS) {
      logger.info('Circuit breaker reset - attempting to reconnect');
      this.circuitBreaker.isOpen = false;
      this.circuitBreaker.failures = 0;
    }

    if (this.circuitBreaker.isOpen) {
      throw new Error('Vapi API circuit breaker is open. Service temporarily unavailable. Please try again later.');
    }
  }

  private recordFailure(): void {
    this.circuitBreaker.failures++;
    this.circuitBreaker.lastFailure = Date.now();

    if (this.circuitBreaker.failures >= CIRCUIT_BREAKER_THRESHOLD) {
      logger.error('Circuit breaker opened', { failures: this.circuitBreaker.failures });
      this.circuitBreaker.isOpen = true;
    }
  }

  private recordSuccess(): void {
    if (this.circuitBreaker.failures > 0) {
      this.circuitBreaker.failures = 0;
    }
  }

  public getCircuitBreakerStatus(): { isOpen: boolean; failures: number; lastFailure: number } {
    return { ...this.circuitBreaker };
  }

  private async request<T>(fn: () => Promise<{ data: T }>, logContext?: Record<string, any>): Promise<T> {
    this.checkCircuitBreaker();
    try {
      const response = await fn();
      this.recordSuccess();
      return response.data;
    } catch (error: any) {
      this.recordFailure();
      const errorDetails = {
        ...logContext,
        status: error?.response?.status,
        statusText: error?.response?.statusText,
        data: error?.response?.data,
        message: error?.message
      };
      logger.exception('Vapi request failed', error as Error, errorDetails);
      throw error;
    }
  }

  // ========== ASSISTANTS ==========

  /**
   * Create a new Vapi assistant
   * @param config Assistant configuration
   * @returns Created assistant object
   * @throws Error if API request fails
   */
  async createAssistant(config: AssistantConfig): Promise<any> {
    const payload: any = {
      name: config.name,
      serverUrl: config.serverUrl,
      serverMessages: config.serverMessages, // Pass serverMessages
      model: {
        provider: config.modelProvider || 'openai',
        model: config.modelName || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: config.systemPrompt
          }
        ]
      },
      voice: {
        provider: config.voiceProvider || 'vapi',
        voiceId: config.voiceId || process.env.VAPI_DEFAULT_VOICE || 'Rohan'
      },
      transcriber: config.transcriber || {
        provider: 'deepgram',
        model: 'nova-2',
        language: config.language || 'en'  // Use stored language
      },
      firstMessage: config.firstMessage || 'Hello! How can I help you today?',
      recordingEnabled: true  // CRITICAL: Enable recording for all calls
    };

    // Only include tools if explicitly provided; some Vapi routes reject tools on creation
    if (config.tools && config.tools.length > 0) {
      payload.tools = config.tools;
    }

    // Add maxDurationSeconds if provided
    if (config.maxDurationSeconds) {
      payload.maxDurationSeconds = config.maxDurationSeconds;
    }

    // DISABLED: Vapi API doesn't support fallbacks property (returns 400 error)
    // const payloadWithFallbacks = mergeFallbacksIntoPayload(payload);
    // return await this.request<any>(() => this.client.post('/assistant', payloadWithFallbacks), { route: 'POST /assistant' });

    return await this.request<any>(() => this.client.post('/assistant', payload), { route: 'POST /assistant' });
  }

  async updateAssistant(assistantId: string, updates: any) {
    // DISABLED: Vapi API doesn't support fallbacks property (returns 400 error)
    // const updatesWithFallbacks = mergeFallbacksIntoPayload(updates);
    // return await this.request<any>(() => this.client.patch(`/assistant/${assistantId}`, updatesWithFallbacks), { route: 'PATCH /assistant/:id', assistantId });

    return await this.request<any>(() => this.client.patch(`/assistant/${assistantId}`, updates), { route: 'PATCH /assistant/:id', assistantId });
  }

  /**
   * Update assistant's server URL (webhook endpoint)
   * Used to dynamically update webhook URLs when ngrok restarts
   *
   * @param assistantId - The Vapi assistant ID
   * @param webhookUrl - The new webhook URL (e.g., https://xyz.ngrok-free.dev/api/webhooks/vapi)
   * @returns Updated assistant object
   */
  async updateAssistantWebhook(
    assistantId: string,
    webhookUrl: string
  ): Promise<any> {
    const updates = {
      serverUrl: webhookUrl,
      serverMessages: [
        'assistant-request',
        'end-of-call-report',
        'function-call',
        'hang',
        'speech-update',
        'status-update',
        'transcript'
      ]
    };

    logger.info('Updating assistant webhook URL', {
      assistantId,
      webhookUrl
    });

    return await this.updateAssistant(assistantId, updates);
  }

  /**
   * CRITICAL: Sync appointment booking tools to agent
   * Constructs tool definitions inline and wires them into the agent's tools array
   * 
   * This function:
   * 1. Loads tool definitions from config
   * 2. Injects tenantId into webhook URLs
   * 3. Updates the agent with the tools array
   * 
   * @param assistantId - The Vapi assistant ID
   * @param tenantId - The organization/tenant ID for multi-tenant routing
   * @param baseUrl - Optional override for webhook base URL
   * @returns Updated assistant object
   */
  async syncAgentTools(assistantId: string, tenantId: string, baseUrl?: string): Promise<any> {
    try {
      // Load tool definitions
      const toolDefinitions = this.getAppointmentBookingTools(baseUrl);

      logger.info('Syncing appointment booking tools to agent', {
        assistantId,
        tenantId,
        toolCount: toolDefinitions.length
      });

      // Update the agent with tools
      const response = await this.updateAssistant(assistantId, {
        tools: toolDefinitions
      });

      logger.info('Successfully synced tools to agent', { assistantId, toolCount: toolDefinitions.length });
      return response;
    } catch (error) {
      logger.error('Failed to sync tools to agent', { assistantId, error: (error as any)?.message });
      throw error;
    }
  }

  /**
   * Get appointment booking tool definitions
   * These are server-type tools that handle: check_availability, reserve_slot, send_sms_reminder
   * 
   * @param baseUrl - Optional override for webhook base URL (defaults to environment variable)
   * @returns Array of VapiTool definitions
   */
  public getAppointmentBookingTools(baseUrl?: string): VapiTool[] {
    const url = baseUrl || process.env.RENDER_EXTERNAL_URL || process.env.BASE_URL || 'https://api.example.com';

    return [
      {
        type: 'server',
        name: 'check_availability',
        description: 'Check available appointment slots for a given date. Returns list of 30-minute time slots respecting business hours and buffer times.',
        server: {
          url: `${url}/api/vapi/tools/calendar/check`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Let me check our availability...',
            'Looking up the schedule...',
            'One moment while I check what we have available...'
          ],
          requestComplete: [
            'Here are the available times:',
            'I found these openings:',
            'We have availability at:'
          ],
          requestFailed: [
            'I\'m having trouble checking the schedule. Can you try again in a moment?',
            'Let me try that again...'
          ]
        }
      },
      {
        type: 'server',
        name: 'reserve_atomic',
        description: 'Atomically reserve an appointment slot using PostgreSQL advisory locks. Prevents double-booking with microsecond-level precision. Returns 10-minute hold that must be confirmed with OTP.',
        server: {
          url: `${url}/api/vapi/tools/booking/reserve-atomic`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Reserving that time for you...',
            'Holding that slot atomically...'
          ],
          requestComplete: [
            'Perfect! That time is reserved for you.',
            'Got it - I\'ve held that appointment for you.'
          ],
          requestFailed: [
            'It looks like someone just booked that time. Let me show you other options.',
            'That slot was just taken. Would another time work?'
          ]
        }
      },
      {
        type: 'server',
        name: 'send_otp_code',
        description: 'Generate and send a 4-digit verification code via SMS to confirm appointment booking. Code expires after 10 minutes or 3 failed attempts.',
        server: {
          url: `${url}/api/vapi/tools/booking/send-otp`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Sending you a verification code...',
            'Just a moment while I send the code...'
          ],
          requestComplete: [
            'Code sent! Check your text message.',
            'Perfect! Look for the code in your text messages.'
          ],
          requestFailed: [
            'I\'m having trouble sending the code. Let me try again...',
            'Unable to send the verification code at the moment.'
          ]
        }
      },
      {
        type: 'server',
        name: 'verify_otp',
        description: 'Verify the 4-digit OTP code from SMS to complete appointment booking. On successful verification, creates confirmed appointment in calendar.',
        server: {
          url: `${url}/api/vapi/tools/booking/verify-otp`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Verifying your code...',
            'Checking that code...'
          ],
          requestComplete: [
            'Code verified! Your appointment is confirmed.',
            'Great! Code matches. You\'re all set.'
          ],
          requestFailed: [
            'That code doesn\'t match. Please check your text and try again.',
            'That\'s not the right code. You have a few more tries.'
          ]
        }
      },
      {
        type: 'server',
        name: 'send_confirmation_sms',
        description: 'Send appointment confirmation SMS to patient after successful OTP verification. Includes date, time, clinic name, and reschedule instructions.',
        server: {
          url: `${url}/api/vapi/tools/booking/send-confirmation`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Sending your confirmation text...',
            'Just a moment while I send that...'
          ],
          requestComplete: [
            'Perfect! Confirmation sent to your phone.',
            'SMS sent! Check your messages for the details.'
          ],
          requestFailed: [
            'I\'m having trouble sending the confirmation. Let me try once more...',
            'Unable to send the SMS at the moment.'
          ]
        }
      },
      {
        type: 'server',
        name: 'send_sms_reminder',
        description: 'Send appointment reminder or confirmation SMS. 10DLC compliant with opt-out language. Includes reschedule link.',
        server: {
          url: `${url}/api/vapi/tools/sms/send`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Sending you a text...',
            'Just a moment while I send that...'
          ],
          requestComplete: [
            'Perfect! You\'ll receive a text shortly with all the details.',
            'SMS sent! Check your messages.'
          ],
          requestFailed: [
            'I\'m having trouble sending the text. Let me try once more...',
            'Unable to send the SMS at the moment.'
          ]
        }
      },
      {
        type: 'server',
        name: 'bookClinicAppointment',
        description: 'Books a clinic appointment on the patient\'s preferred date and time. Creates a booking record in the database and syncs the event to Google Calendar. Use this tool to finalize the appointment booking.',
        server: {
          url: `${url}/api/vapi/tools/bookClinicAppointment`,
          method: 'POST'
        },
        messages: {
          requestStart: [
            'Booking your appointment now...',
            'Just a moment while I save that to the calendar...',
            'Recording your appointment...'
          ],
          requestComplete: [
            'Perfect! Your appointment is confirmed and added to your calendar.',
            'All set! I\'ve booked your appointment and sent a confirmation.',
            'Great! Your appointment is confirmed for that date and time.'
          ],
          requestFailed: [
            'I\'m having trouble booking that appointment. Let me try again...',
            'Unable to complete the booking at the moment. Can you provide your email again?'
          ]
        }
      }
    ];
  }

  async getAssistant(assistantId: string) {
    return await this.request<any>(() => this.client.get(`/assistant/${assistantId}`), { route: 'GET /assistant/:id', assistantId });
  }

  async listAssistants() {
    return await this.request<any>(() => this.client.get('/assistant'), { route: 'GET /assistant' });
  }

  /**
   * Hard delete assistant from Vapi
   * @param assistantId - Vapi assistant ID
   * @returns Void on success
   * @throws Error if API request fails
   */
  async deleteAssistant(assistantId: string): Promise<void> {
    await this.request<void>(() => this.client.delete(`/assistant/${assistantId}`), { route: 'DELETE /assistant/:id', assistantId });
  }

  async getTool(toolId: string) {
    return await this.request<any>(() => this.client.get(`/tool/${toolId}`), { route: 'GET /tool/:id', toolId });
  }

  async validateConnection(): Promise<boolean> {
    try {
      // Use this.request() to respect circuit breaker
      await this.request<any>(() => this.client.get('/assistant', { params: { limit: 1 } }), { route: 'GET /assistant (validation)' });
      return true;
    } catch (error) {
      logger.warn('Connection validation failed', { error: (error as any)?.message });
      return false;
    }
  }

  async listVoices() {
    try {
      const response = await this.client.get('/voice');
      return response.data;
    } catch (error) {
      logger.warn('Failed to list voices from API, might not be supported', { error: (error as any)?.message });
      return [];
    }
  }

  // ========== CALLS ==========

  /**
   * @ai-invariant DO NOT REMOVE the assertOutboundCallReady() call below.
   * It validates that assistantId is present, phoneNumberId is a Vapi UUID
   * (not a raw +1... phone string), and customer number exists.
   * Removing it will allow silent failures that are hard to debug.
   */
  async createOutboundCall(params: CreateCallParams) {
    // Pre-flight validation â€” catches bad data before it reaches the Vapi API
    assertOutboundCallReady({
      assistantId: params.assistantId,
      phoneNumberId: params.phoneNumberId,
      customerNumber: params.customer?.number
    });

    const payload: any = {
      assistantId: params.assistantId,
      phoneNumberId: params.phoneNumberId,
      customer: {
        number: params.customer.number,
        name: params.customer.name
      }
    };

    // NOTE: idempotencyKey was removed - Vapi API rejects this field with:
    // "property idempotencyKey should not exist"

    // Add assistantOverrides for lead personalization (variableValues + metadata + firstMessage)
    if (params.assistantOverrides) {
      payload.assistantOverrides = {};
      if (params.assistantOverrides.variableValues) {
        payload.assistantOverrides.variableValues = params.assistantOverrides.variableValues;
      }
      if (params.assistantOverrides.metadata) {
        payload.assistantOverrides.metadata = params.assistantOverrides.metadata;
      }
      if (params.assistantOverrides.firstMessage) {
        payload.assistantOverrides.firstMessage = params.assistantOverrides.firstMessage;
      }
    }

    return await this.request<any>(() => this.client.post('/call/phone', payload), { route: 'POST /call/phone' });
  }

  async getCall(callId: string) {
    return await this.request<any>(() => this.client.get(`/call/${callId}`), { route: 'GET /call/:id', callId });
  }

  async createWebSocketCall(params: {
    assistantId: string;
    audioFormat: {
      format: 'pcm_s16le' | 'mulaw';
      container: 'raw';
      sampleRate: number;
    };
  }) {
    const payload = {
      assistantId: params.assistantId,
      transport: {
        provider: 'vapi.websocket',
        audioFormat: params.audioFormat
      }
    };

    return await this.request<any>(() => this.client.post('/call', payload), { route: 'POST /call' });
  }

  async endCall(callId: string) {
    return await this.request<any>(() => this.client.delete(`/call/${callId}`), { route: 'DELETE /call/:id', callId });
  }

  async listCalls(limit: number = 50) {
    return await this.request<any>(() => this.client.get('/call', { params: { limit } }), { route: 'GET /call' });
  }

  // ========== PHONE NUMBERS ==========

  async createVapiPhoneNumber(name: string = 'Default Outbound Number') {
    const payload = {
      provider: 'vapi',
      name: name
    };

    const result = await this.request<any>(() => this.client.post('/phone-number', payload), { route: 'POST /phone-number' });
    logger.info('Created Vapi phone number', { phoneNumberId: result?.id });
    return result;
  }

  async importTwilioNumber(params: ImportTwilioParams) {
    const payload = {
      provider: 'twilio',
      number: params.phoneNumber,
      twilioAccountSid: params.twilioAccountSid,
      twilioAuthToken: params.twilioAuthToken
    };

    return await this.request<any>(() => this.client.post('/phone-number', payload), { route: 'POST /phone-number (twilio)' });
  }

  async getPhoneNumber(phoneNumberId: string) {
    return await this.request<any>(() => this.client.get(`/phone-number/${phoneNumberId}`), { route: 'GET /phone-number/:id', phoneNumberId });
  }

  async listPhoneNumbers() {
    const payload: any = await this.request<any>(() => this.client.get('/phone-number'), { route: 'GET /phone-number' });
    if (Array.isArray(payload)) return payload;
    if (Array.isArray(payload?.data)) return payload.data;
    if (Array.isArray(payload?.items)) return payload.items;
    logger.warn('Unexpected phone numbers response format, returning empty array', { payloadType: typeof payload });
    return [];
  }

  async updatePhoneNumber(phoneNumberId: string, updates: any) {
    return await this.request<any>(() => this.client.patch(`/phone-number/${phoneNumberId}`, updates), { route: 'PATCH /phone-number/:id', phoneNumberId });
  }

  async deletePhoneNumber(phoneNumberId: string) {
    return await this.request<any>(() => this.client.delete(`/phone-number/${phoneNumberId}`), { route: 'DELETE /phone-number/:id', phoneNumberId });
  }

  /**
   * Get default demo delivery tools in modern Vapi tools format
   * These are server-type tools that send demo videos via email, SMS, or WhatsApp
   */
  /**
   * Get default demo tools for new assistants
   * Returns modern 'server' type tools instead of legacy functions
   */
  public getDefaultDemoTools(): VapiTool[] {
    const baseUrl = process.env.RENDER_EXTERNAL_URL || process.env.BASE_URL;
    if (!baseUrl || baseUrl.includes('localhost')) {
      logger.warn('BASE_URL not configured or is localhost - demo tools may not work in production', { baseUrl });
    }

    return [
      {
        type: 'server',
        name: 'send_demo_email',
        description: 'Sends a demo video to the prospect via email. ASK FOR EMAIL FIRST.',
        server: {
          url: `${baseUrl}/api/vapi/tools/email`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending that email now...', 'I am sending the demo to your email...'],
          requestComplete: ['Email sent successfully!'],
          requestFailed: ['I had trouble sending the email. Let me try again.']
        }
      },
      {
        type: 'server',
        name: 'send_demo_whatsapp',
        description: 'Sends a demo video or message via WhatsApp.',
        server: {
          url: `${baseUrl}/api/vapi/tools/whatsapp`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending WhatsApp message...', 'One moment while I send that...'],
          requestComplete: ['WhatsApp message sent!'],
          requestFailed: ['Unable to send via WhatsApp right now.']
        }
      },
      {
        type: 'server',
        name: 'send_demo_sms',
        description: 'Sends a demo video or text via SMS.',
        server: {
          url: `${baseUrl}/api/vapi/tools/sms`,
          method: 'POST'
        },
        messages: {
          requestStart: ['Sending text message...', 'Texting you the demo now...'],
          requestComplete: ['Text sent! Check your messages.'],
          requestFailed: ['Could not send the SMS.']
        }
      }
    ];
  }

  /**
   * Get default demo delivery function definitions for Vapi assistant
   * These functions allow the AI to send demo videos via email, SMS, or WhatsApp
   * @deprecated Use getDefaultDemoTools() for modern tools format
   */
  public getDefaultDemoFunctions() {

    const baseUrl = process.env.RENDER_EXTERNAL_URL || process.env.BASE_URL;
    if (!baseUrl || baseUrl.includes('localhost')) {
      logger.warn('BASE_URL not configured or is localhost - demo functions may not work in production', { baseUrl });
    }

    return [
      {
        name: 'send_demo_email',
        description: 'Send a demo video via email to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_email: {
              type: 'string',
              description: 'The prospect\'s email address'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_email', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-email`,
        //   method: 'POST'
        // }
      },
      {
        name: 'send_demo_whatsapp',
        description: 'Send a demo video via WhatsApp to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_phone: {
              type: 'string',
              description: 'The prospect\'s phone number with country code'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_phone', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-whatsapp`,
        //   method: 'POST'
        // }
      },
      {
        name: 'send_demo_sms',
        description: 'Send a demo video via SMS to a prospect',
        parameters: {
          type: 'object',
          properties: {
            prospect_name: {
              type: 'string',
              description: 'The prospect\'s full name'
            },
            prospect_phone: {
              type: 'string',
              description: 'The prospect\'s phone number with country code'
            },
            clinic_name: {
              type: 'string',
              description: 'The name of their clinic or practice'
            },
            demo_type: {
              type: 'string',
              enum: ['outbound_intro', 'inbound_intro', 'feature_overview'],
              description: 'Type of demo to send'
            },
            agent_id: {
              type: 'string',
              description: 'The ID of the calling agent'
            },
            call_id: {
              type: 'string',
              description: 'The current call ID (optional)'
            }
          },
          required: ['prospect_name', 'prospect_phone', 'clinic_name', 'demo_type', 'agent_id']
        },
        // NOTE: Server URL commented out - enable when demo endpoint is ready
        // server: {
        //   url: `${baseUrl}/api/demo/send-sms`,
        //   method: 'POST'
        // }
      }
    ];
  }
}

export default VapiClient;
