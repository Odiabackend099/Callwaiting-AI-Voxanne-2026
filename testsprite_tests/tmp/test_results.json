[
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "359e1d9d-24e2-494a-a9cb-34d7a2e705a0",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC001-View key analytics widgets on the Dashboard (calls, appointments, sentiment)",
    "description": "Verifies that after login the dashboard shows total calls today, appointments booked, and average sentiment widgets.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the email into the email field (index 1637) and password into the password field (index 1645), then click the 'Sign In' button (index 1650).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Input email into the email field, input password into the password field, then click the Sign In button to submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert \"/dashboard\" in frame.url\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[2]/div[1]/div[2]/div[1]/div')\n        assert await elem.is_visible()\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[2]/div[3]/div[2]/div[1]/div')\n        assert await elem.is_visible()\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[2]/div[4]/div[2]/div[1]/div')\n        assert await elem.is_visible()\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078798473494//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.349Z",
    "modified": "2026-02-26T04:06:38.585Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "06b7d592-d40f-4bae-a2eb-f8f26b087cf4",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC003-Open a recent activity item to view call record details",
    "description": "Verifies that clicking an activity item opens a detailed record showing cost, appointment ID, and tools used.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page (element index 77).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'Sign In' button to log in (perform the login attempt).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reload' button on the error page to retry loading the login page so the login and subsequent activity checks can proceed. ASSERTION: The Reload button (index 75) is present and clickable.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[2]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email (index 3) and Password (index 4) fields with the provided credentials and click the Sign In button (index 6) to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Email (index 275) with 'ceo@demo.com', fill Password (index 283) with 'demo123', then click Sign In (index 288) to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first item in the Recent Activity list to open its detailed record (target element index 869). After the page updates, verify that 'Cost', 'Appointment ID', and 'Tools used' are visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div[2]/div/div[2]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=Cost').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Appointment ID').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Tools used').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Clicking the first item in Recent Activity did not open a detailed record panel containing 'Cost', 'Appointment ID', or 'Tools used'.\n- The dashboard remained on the Recent Activity list; no detail view or record fields were rendered after the click.\n- A search for the strings 'Cost', 'Appointment ID', and 'Tools used' on the current page returned NOT FOUND.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078845622925//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.354Z",
    "modified": "2026-02-26T04:07:25.733Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "cbeeca16-f7f6-4ef2-8e2f-5c5f95e70023",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC005-Dashboard loads aggregated metrics without showing an error banner",
    "description": "Verifies that when dashboard stats load successfully, the page does not show a re-authentication error banner.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /login (explicit test step)\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the provided email into the email field (element [82]) and the password into the password field (element [90]), then click the Sign In button (element [95]).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to submit the login form again by clicking the 'Sign In' button (element [279]) to trigger navigation to the dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click the Sign In button to submit the form and trigger navigation to the dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Final assertions appended to the test\n        frame = context.pages[-1]\n        # Verify URL contains \"/dashboard\"\n        assert \"/dashboard\" in frame.url\n        # Verify Dashboard stats section is visible (element [695])\n        assert await frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[2]/div[1]/div[2]/div[1]/div').is_visible()\n        # The page does not contain any element in the provided list with the text \"re-authenticate\".\n        # According to the test plan, if a feature/element does not exist we must report the issue and stop.\n        raise RuntimeError(\"Element with text 're-authenticate' not found in the available elements; cannot assert its invisibility. Test marked as done.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078742311296//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.361Z",
    "modified": "2026-02-26T04:05:42.441Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "40871372-bf7f-4334-9e5f-c4dd2f07989a",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC008-Search call logs by caller name or phone number and open call details",
    "description": "Verifies that searching call logs filters the list and a matching call can be opened to view details.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /login (required test step: use explicit navigate to /login as instructed).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with 'ceo@demo.com', fill the password field with 'demo123', then click the 'Sign In' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Retry signing in by clicking the 'Sign In' button again to trigger the login request and wait for a redirect to /dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=John Doe').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Call details').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed: the application displayed a 'Connection failed. Please check your internet connection and try again.' banner after attempting to sign in.\n- Dashboard page did not load after sign in; the current URL remained on /login.\n- Repeated sign-in attempts (2) did not resolve the issue; the page shows a persistent 'Signing In...' state and no navigation to dashboard occurred.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078675243149//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.368Z",
    "modified": "2026-02-26T04:04:35.379Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "a0007181-62a6-45fc-bcff-6474f0e61ee1",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC009-Filter call logs by status and date range",
    "description": "Verifies that applying a status filter and a date-range filter updates the call list results.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page (index 77).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click the 'Sign In' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sign In' submit button to attempt login (index 1783).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=Completed').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Calls').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed - login form remained visible after submitting credentials.\n- Dashboard page did not load - current URL remains on the login page ('/login').\n- Calls page could not be reached because the user was not authenticated, so status and date-range filters cannot be tested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/177207861399337//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.373Z",
    "modified": "2026-02-26T04:03:34.100Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "05a151ae-95bb-47f1-8d3f-da188edcce1a",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC010-Send an SMS follow-up from call details",
    "description": "Verifies that an SMS follow-up can be composed and sent from a call detail view and a success message is shown.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link in the page header to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=Call details').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=SMS message').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=SMS sent').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login page at /login returned ERR_EMPTY_RESPONSE and did not load the application UI.\n- No interactive application elements were present on the /login page (only the browser error and a reload button).\n- Unable to proceed with authentication or access the dashboard; subsequent test steps cannot be executed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078512486859//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.378Z",
    "modified": "2026-02-26T04:01:52.609Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "b0394a9b-9f95-4c28-8251-aac41e781af7",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC011-Delete a call record from the call logs list",
    "description": "Verifies that a call record can be deleted with confirmation and is removed from the list.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page (use interactive element index 77).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'Sign In' button to submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reload' button (index 75) to retry loading the /login page and recover from the ERR_EMPTY_RESPONSE.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[2]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 3) with ceo@demo.com, fill the password (index 4) with demo123, then click the Sign In button (index 6) to submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 308) with ceo@demo.com, fill the password (index 316) with demo123, then click the Sign In button (index 321).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Call Logs' navigation link to open the Calls/Call Logs page (interactive element index 610).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the full activity/call list so a specific call row can be selected (click 'View All Activity'). Then locate a visible unique value from the first call row to search or open.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Michael Chen' into the call search field (index 1095), press Enter to run the search, open the first matching call row (index 1423), then click the Delete call button for that row (index 1223).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Michael Chen')\n        \n        # -> Click the first matching call row to open its details (click element index 1633).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[5]/div/table/tbody/tr[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Delete call' button for the opened call (interactive element index 1624) to open the confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[5]/div/table/tbody/tr[2]/td[7]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Delete' (confirm) button in the confirmation dialog to confirm deletion (interactive element index 1672).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div[3]/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=Michael Chen').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Confirm').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Deleted').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Deletion did not complete: no final confirmation text 'Deleted' or 'Deleted successfully' found on the visible page after confirming deletion.\n- Confirmation modal remained in a processing state showing 'Confirming...' instead of a success message.\n- The call record for 'Michael Chen' (+15555551234) is still present in the call list (two identical rows visible), so the record was not removed.\n- Multiple wait attempts (total ~14s) produced no change in UI state from processing to deleted, indicating the deletion did not finish in the UI.\n- No alternative UI feedback or error message indicating deletion failure was shown, preventing verification of a successful deletion.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/177207914461017//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.383Z",
    "modified": "2026-02-26T04:12:24.764Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "7c3c1357-8444-4334-bbad-7408982c0d39",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC015-View appointments list with pagination and open an appointment to see linked call data",
    "description": "Verifies the user can browse the appointments list, paginate, open an appointment, and see linked call information in details.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link in the page header to open the login page (click element index 89).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reload' button (element index 74) to retry loading the /login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields on the /login page and click the Sign In button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Appointments' navigation item in the dashboard (interactive element index 386).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Edit button to open the appointment details panel and then check the details for linked call information (e.g., call link, call record, or related call metadata). If the details panel doesn't show linked call info, report the missing feature.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Edit button to open the appointment details panel and then inspect the panel for linked call information (call link, call record, or related call metadata).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078842025497//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.389Z",
    "modified": "2026-02-26T04:07:22.163Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "cb658203-41f8-4ba3-9075-76360e3d7983",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC016-Open appointment details and verify call Golden Record/link is visible",
    "description": "Verifies appointment details include visible linked call data (Golden Record) for traceability.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link in the header to open the login page (index 77).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'Sign In' button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'Sign In' button again (use email index 1764, password index 1772, sign-in button index 1777).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form using email index 1958 and password index 1966, then click the Sign In button (index 1971) to attempt to log in. After that, proceed to click 'Appointments' in the dashboard navigation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Accept All' cookies button (index 2054) to clear the cookie banner so the page UI is fully accessible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[3]/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Appointments' link in the left navigation (index 2270) to open the appointments list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Appointments card in the dashboard metrics (index 2401) to open the appointments list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[2]/div[3]/div[2]/div[1]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Edit button (index 2876) to open the appointment details so the page can be checked for 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Accept All' on the cookie banner to remove the banner, then open the first appointment details by clicking the Edit button (index 2876).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[3]/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Edit button to open the appointment details so the page can be checked for the text 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the second appointment's Edit button (index 2905) to open the appointment details so the page can be checked for the texts 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[2]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Edit button (index 2876) to open the appointment details so the page can be checked for the texts 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open an appointment details view by clicking the second appointment's Edit button (index 2905), then check the resulting view for the texts 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[2]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the third appointment's Edit button (index 2934) to open the appointment details; after the click, check the view for the texts 'Appointment Details' and 'Linked Call'. If the feature is missing, report the issue and finish.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment row (index 2943) to open the appointment details, then verify that the texts 'Appointment Details' and 'Linked Call' are visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the third appointment's Edit button (index 2934) to try to open the appointment details so the view can be checked for the texts 'Appointment Details' and 'Linked Call'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Appointment Details').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Linked Call').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Appointment details view did not open after multiple attempts using Edit buttons and row clicks\n- No text 'Appointment Details' found on the Appointments page\n- No text 'Linked Call' found on the Appointments page\n- Edit buttons and appointment row clicks did not reveal a details panel or modal",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772079100626157//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.395Z",
    "modified": "2026-02-26T04:11:40.783Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "f108b0df-96a6-4586-a55f-8fe869f719e5",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC017-Filter appointments by Pending status and verify results reflect the filter",
    "description": "Verifies filtering the appointments list by Pending updates the visible results.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /login (http://localhost:3000/login) so the login form can be filled.\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the email into the Email address field (interactive element 82) as the next immediate action.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to sign in again by clicking the 'Sign In' button (interactive element index 279).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Input credentials into the visible Email and Password fields and submit the form (use Enter key) to attempt sign-in once more. ASSERTION: After submitting, the app should navigate to the dashboard (will verify after action).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        # -> Click 'Appointments' in the dashboard navigation (interactive element index 597).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[5]/div/span').nth(0)\n        assert await elem.is_visible()\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078816514699//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.400Z",
    "modified": "2026-02-26T04:06:56.667Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "d111ea68-428f-46d0-a3e9-05ea62761332",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC018-Pending appointment reschedule to a valid new date and verify status/date updates",
    "description": "Verifies a pending appointment can be rescheduled with a valid new date and the updated information is visible afterward.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /login (use explicit navigate to /login as instructed).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type 'ceo@demo.com' into the email field (index 1752).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to recover the page by clicking the 'Reload' button (interactive element index 74).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields again and click the 'Sign In' button to attempt login (use indexes 82, 90, 95).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Appointments' navigation link in the sidebar to open the Appointments page (index 385).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the 'Pending' option from the Status dropdown (index 911) and then open the first appointment for editing by clicking its Edit button (index 1012).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit button for the first appointment to open the edit/reschedule modal (click element index 1165).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit button for the first appointment again to open the edit/reschedule modal (element index 1165).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit button for the second appointment (element index 1194) to open the edit/reschedule modal so a new date/time can be entered.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[2]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit control for the second appointment again (use index 1195) to open the edit/reschedule modal so date/time fields and save/update controls become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[2]/td[7]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment's Date & Time cell (index 1167) to open the appointment details/edit view so it can be rescheduled. ASSERTION: Clicking the row/cell should open the appointment details if the Edit button is not functioning.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]/td[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment row (tr element index 1203) to attempt to open the appointment details/reschedule view (alternative to Edit button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment row (tr) again (index 1203) to attempt to open the appointment details/reschedule view (alternative to Edit buttons).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/appointments' in frame.url\n        await expect(frame.locator('text=Pending').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Appointment Details').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Appointment Rescheduled').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Edit button clicks for multiple appointments did not open an edit/reschedule modal or display date/time input fields.\n- Clicking the appointment row and the Date & Time cell did not open appointment details or reschedule UI.\n- No Save/Update controls or date/time input fields are present in the page's interactive elements, preventing rescheduling.\n- Multiple attempts were made (Edit clicked for first appointment 2 times, second appointment 2 times, row/cell clicked 2 times) with no result.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772079044236392//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.405Z",
    "modified": "2026-02-26T04:10:44.375Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "ae2ec5eb-9778-4234-b385-a93479e794ba",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC019-Complete reschedule submit and verify confirmation is visible",
    "description": "Verifies the reschedule form can be submitted and a visible success/updated state appears.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the \"Sign In\" link on the landing page to open the login page (use element index 87).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the provided email into the email field (index 1585), type the provided password into the password field (index 1593), then click the Sign In button (index 1598).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Accept All' on the cookie consent banner (index 1719) to clear the overlay so dashboard navigation can be accessed, then locate the 'Appointments' navigation item.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[3]/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields again and click the Sign In button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Appointments' navigation item in the sidebar (index 1945).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the first appointment in the appointments list (the appointment entry starting ' Appointment for Michael Chen ...').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div[2]/div/div[2]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit button for the Michael Chen appointment to open the reschedule/edit form (use element index 2608).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to open the reschedule/edit form for the Michael Chen appointment by clicking the appointment's action container (index 2609) to reveal the form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reschedule' button in the appointment modal to open the reschedule form (index 2721).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the reschedule form so the 'New date' input appears (click the Reschedule button again if necessary), then enter '2030-01-15' into the date field and save. Immediate action: attempt to open the reschedule form by clicking the Reschedule button.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Rescheduled').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Reschedule form does not contain a visible 'New date' input or datepicker on the page.\n- The reschedule action triggers a JavaScript prompt (auto-closed) instead of a visible form, preventing automated input.\n- No interactive input element was available to enter '2030-01-15'.\n- The automated test cannot verify the 'Rescheduled' confirmation because the UI requires user prompt input that cannot be provided via visible DOM controls.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772079084785691//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.411Z",
    "modified": "2026-02-26T04:11:25.044Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "9aaa4ff9-b391-44ce-80c0-b6c533820255",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC020-Cancel an appointment and confirm status becomes Cancelled",
    "description": "Verifies the user can cancel an appointment, confirm the action, and see the updated cancelled status in UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page (use element index 77).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type email and password into the login form and click the 'Sign In' submit button to sign in\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Reload button (index 75) to retry loading the /login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[2]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt sign-in again by filling the email and password fields on the visible login form (inputs index 3 and 4) and clicking the 'Sign In' button (index 6). ASSERTION: Email input (index 3), Password input (index 4), and Sign In button (index 6) are visible before submitting.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Cancelled').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- ASSERTION: Login failed - error page with text \"This page isn't working\" and \"ERR_EMPTY_RESPONSE\" was displayed after submitting credentials.\n- ASSERTION: Reload button existed but was not interactable (click failed) preventing a simple retry of the error state.\n- ASSERTION: After a second sign-in attempt the page remained on the login form and the dashboard did not load.\n- ASSERTION: Appointments page could not be accessed because the user is not authenticated / dashboard was not reached.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/177207863597877//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.417Z",
    "modified": "2026-02-26T04:03:56.130Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "3e29248c-cb80-499d-b69f-7f867cb4e0e5",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC021-Attempt to reschedule with an invalid date and verify validation error is shown",
    "description": "Verifies invalid reschedule input is blocked with a visible validation message and the appointment is not updated.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link (element index 77) to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with provided credentials and click the 'Sign In' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Retry the 'Sign In' action by clicking the Sign In button (index 1663) to attempt to reach the dashboard. If the connection error persists after this second attempt, stop and report failure.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Appointments' navigation item to open the appointments list (element index 2008). After the page loads, proceed to open the first appointment and test reschedule validation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[2]/nav/div[1]/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the first appointment by clicking the appointment card for Michael Chen (click element index 2286).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div[2]/div/div[2]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the appointment details by clicking the Edit button for the Michael Chen row (element index 2671), then proceed to click 'Reschedule'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Edit button for the Michael Chen row (index 2671) to open the appointment edit controls so the Reschedule option becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[3]/div/table/tbody/tr[3]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reschedule' button (element index 2784) to open the reschedule form so an invalid date can be entered and validation verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Dismiss the cookie banner so reschedule form controls are fully accessible, then open the reschedule input so 'invalid-date' can be entered.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[3]/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[3]/main/div/div/div[4]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Invalid date').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Reschedule flow requires a browser JS prompt for entering the new date which cannot be interacted with via page DOM elements.\n- No inline 'New date' input field was found in the appointment modal after activating Reschedule.\n- The automation environment auto-closed the JS prompt dialogs, preventing entering 'invalid-date'.\n- No 'Save' button or equivalent submit control is present in the page DOM after triggering Reschedule, so the invalid input cannot be submitted.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078951927207//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.422Z",
    "modified": "2026-02-26T04:09:12.087Z"
  },
  {
    "projectId": "b4d1e6a8-0fa4-4efe-88de-64d5bb04f83c",
    "testId": "c7ef3317-da08-4f45-ba6e-7f6fbbe79c6d",
    "userId": "4448f4b8-a0d1-705b-ba05-4f1442171177",
    "title": "TC023-Edit an existing agent and save changes (inbound tab)",
    "description": "Verifies a user can edit an inbound agents basic details and see a visible save confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/main/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reload' button (interactive element index 74) to attempt to load the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the Sign In button to attempt login (perform the next three actions).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Reload button (interactive element index 74) to attempt to recover the page and load the application.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields (indexes 3 and 4) with provided credentials and click the Sign In button (index 6). After that, verify navigation to the dashboard (URL contains '/dashboard').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ceo@demo.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('demo123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/dashboard' in frame.url\n        await expect(frame.locator('text=Agent').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Saved').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed - server returned ERR_EMPTY_RESPONSE after submitting valid credentials.\n- Dashboard page did not load after sign-in; URL does not contain '/dashboard'.\n- Sign In button did not navigate away from /login; login form remains visible after submission.\n- Reload button interaction was inconsistent or stale, indicating unstable server responses.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/4448f4b8-a0d1-705b-ba05-4f1442171177/1772078659272226//tmp/test_task/result.webm",
    "created": "2026-02-26T04:00:10.429Z",
    "modified": "2026-02-26T04:04:19.386Z"
  }
]
